# HTTP Cookie Persistence
Random thoughts:
- When removing/decommissioning nodes from a load-balanced pool fronted by a virtual server that relies on cookie-insert persistence, keep in mind that clients will retain the persistence cookie that tells the load balancer to send them to a specific node. If not managed correctly, this will tell the load balancer to send clients to one of the nodes that was removed from the pool, which will usually return a TCP reset to the client since the node is no longer part of the load balancer's connection table.
- Getting into the nitty-gritty: persistence cookies typically contain a hashed/encoded value that contains a specific node `address:port` combination. When the client's browser sends a request containing the persistence cookie, the load balancer directs the connection to the node specified in the cookie.
  - A coworker of mine recently observed this behavior in the form of user complaints when they decommissioned two web servers, and proposed a few solutions:
    1. Tell users to clear their cookie for the website. Far from ideal - getting users to do what you want them to is often harder than getting computers to do what you want them to. However, the message would be simple enough for a helpdesk technician to communicate to the average user as a workaround in a pinch.
    2. Change the persistence configuration on the virtual server. The virtual server in question was configured to present HTTP session persistence cookies by default. This meant that the persistence cookie lifespan was at the mercy of each client's browser to determine what an "HTTP session" was. For most modern browsers, this almost certainly meant "until the browser window is closed." While a time-based cookie expiration could be configured, the existing cookies cached by client browsers still had to be addressed.
  - In light of those challenges, I proposed the following instead:
    - Add the nodes back to the pool in a disabled state. This would allow the load balancer to make a more informed load balancing decision based on the state of the pool members. Depending on the load balancing platform and the pool/node configuration options available, the response could vary from ungraceful (TCP/HTTP error, followed by new load balancing decision and subsequent persistence cookie on page refresh) to seamless (detect that the target node is down, send the client to a healthy node, and return a new persistence cookie).
    - Add logging to the virtual server to inspect the target specified in each persistence cookie, and filter by the addresses of the servers to be decommissioned. Then, remove the servers from the pool for good once a week had passed or the observed logs reported zero hits within a 48-hour window, whichever of those two events came first.
  - The issue ended up being moot because a short conversation with the developers of the web application revealed that the application was stateless, obviating the need for persistence in the first place.
  - I'll spare you the didactic conclusion that is common with such tales, but I hope this was helpful anyways.
